# ** 복잡도 **
# 1. 시간 복잡도 : 특정 크기 입력에 대하여 알고리즘의 수행 시간 분석
# 2. 공간 복잡도 : 특정한 크기의 입력에 대하여 알고리금의 메모리 사용량 분석
# => 동일한 기능을 수행하는 알고리즘이라면, 일반적으로 복잡도가 낮을 수록 좋은 알고리즘이다.

# ** 빅오 표기법 **
# 가장 빠르게 증가하는 항만을 고려하는 표기법 -> 함수의 상항만을 나타나게 된다.
#  BETTER : 상수시간 >> 로그시간 >> 선형시간 >> 이차 시간 >> 삼차 시간 >> 지수 시간 >> : WORSE

# ** 시간 복잡도 계산해보기  **
# 1. n개의 수를 받아 총합을 계산하는 예제 -> n에 연산 수가 비례 => O(n)
# 2. 2중 반복문 => O(n^2)

# ** 알고리즘 설계  **
# 코딩 테스트의 문제에서는 통상 1~5초 가량임 -> 대략 5초라고 생각하고 문제를 풀어야함.

# ** @@@ 시간 제한이 1초인 문제를 만났을 때 기준  **
# N의 범위가 500인 경우 : 시간 복잡도가 O(N^3)인 알고리즘을 설계하면 문제를 풀 수 있습니다.
# N의 범위가 2,000인 경우 : 시간 복잡도가 O(N^2)인 알고리즘을 설계하면 문제를 풀 수 있습니다.
# N의 범위가 100,000인 경우 : 시간 복잡도가 O(NlogN)인 알고리즘을 설계하면 문제를 풀 수 있습니다.
# N의 범위가 10,000,000인 경우 : 시간 복잡도가 O(N)인 알고리즘을 설계하면 문제를 풀 수 있습니다.

# *** @@@ 알고리즘 문제 해결 과정 ***
# 1. 지문 읽기 및 컴퓨터적 사고
# 2. 요구사황(복잡도) 분석
# 3. 문제 해결을 위한 아이디어 찾기
# 4. 소스 코드 설계 및 코딩
# => 일반적으로 대부분의 문제 출제자들은 핵심 아이디어를 캐치한다면, 간결하게 소스코드를 작성할 수 있는 형태로 문제를 출제한다.

# *** 수행 시간 측정 소스 코드 예제 ***
# 일반적인 알고리즘 문제 해결 과정은 다음과 같다.

import time
Start_time = time.time() # 측정 시작

# 프로그램 소스 코드
total = 0
for i in range(5):
    total += i

end_time = time.time() # 측정 종료
print("time:", end_time - Start_time) # 수행 시간 출력